프로그래밍: 컴퓨터에게 일을 시키기 위해 프로그래밍 언어로 만든 명령어 집합인 프로그램을 만드는 일

컴파일: 프로그래밍 언어를 기계어로 바꾸어 주는 일

컴파일러: 기계어로 바꾸어 주는 프로그램

자바: 플랫폼에 독립적인 프로그래밍을 할 수 있음. thanks to 자바 가상 머신 (c는 안됨)

특징: 

객체지향 프로그램으로 유지 보수와 확장성이 좋다.

안정적이다.

풍부한 라이브러리와 오픈소스 연동

이진수

비트(bit) : 컴퓨터에서 자료를 표현하는 최소 단위 0 또는 1

바이트(byte): 8 bit

이진수: 컴퓨터에서 표현되는 자료의 형태

8 진수: 이진수를 3비트씩 모아서 표현

16진수: 이진수를 4비트씩 모아서 표현

음수:

2의 보수로 표현

양수와 음수는 더해서 0이 되어야 함 (원래 이진수와 2의 보수를 더한 후 앞의 1을 빼면 0이 되어야함)

2의 보수 만드는 방법: 1의 보수를 취하고 나서 1을 더해준다

변수 선언하기:

자료형 변수이름;

ex) int age;

변수와 메모리:

변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것

메모리의 변수 이름으로 참조

변수 이름:

영문자나 숫자를 사용함. 단 숫자로 시작할 수 없음

특수 문자 중에는 _와 $만 사용 가능

예약어는 사용할 수 없음

변수는 그 쓰임에 맞는 이름으로 명명하는 것이 가독성에 좋음

camel notation을 씀

자료형:

- 기본형: 자바 언어에서 기본적으로 제공해 주는 자료형
  - 메모리의 크기가 정해져 있음
  - 정수형, 문자형, 실수형, 논리형
- 참조형: 클래스 자료형
  - JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스
  - 클래스에 따라 사용하는 크기가 다름

![image-20191216132344887](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191216132344887.png)

가장 앞의 bit는 msb로 쓰지 않는다

32bit이면 (-2^31)~(2^31-1)을 표현한다



문자 자료형:

내부적으로는 비트의 조합으로 표현

인코딩 - 각 문자에 따른 특정한 숫자 값(코드값)을 부여

디코딩 - 숫자 값을 원래의 문자로 변환

문자세트: 문자를 위한 코드 값 (숫자 값) 들을 정해놓은 세트

아스키(ASCII): 1바이트로 영문자, 숫자, 특수문자 등을 표현 함

유니코드 (Unicode): 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적

문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장됨



실수:

double 자료형이 기본

float를 사용할 때는 f, F 식별자를 사용

실수를 지수부와 가수부로 표현함

ex) 1.0 (가수) * 10^-1(지수)

![image-20191217092443673](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191217092443673.png)

부동 소수점 방식의 오류

지수와 가수로 표현되는 부동 소수 점은 0을 표현할 수 없음

약간의 오차가 발생할 수 있다



논리: 

boolean으로 표현



자료형 없이 변수 사용하기 (자바 10):

지역 변수 자료형 추론 (local variable type inference)

변수에 대입되는 값을 보고 컴파일러가 추론

지역 변수만 자료형 없이 변수 사용 가능

var 로 변수 선언 가능



상수와 리터럴

상수 (constant): 변하지 않는 수

리터럴 (literal): 프로그램에서 사용하는 모든 숫자, 값, 논리 값

모든 리터럴 상수 풀 (constant pool)에 저장되어 있음

상수 풀에 저장될 때 정수는 int, 실수는 double로 저장 됨



형 변환

서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어남

묵시적 형 변환 (implit type conversion): 작은 수에서 큰 수로 덜 정밀한 수에서 더 정밀한 수로 대입되는 경우

명시적 형 변환 (explit type conversion): 변환 되는 자료 형을 명시. 자료의 손실이 발생 할 수 있음.

![image-20191217094610226](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191217094610226.png)

정수 to 실수: 묵시적 형 변환

실수 to 정수:  명시적 형 변환



2진수, 8진수, 16진수

2진수: 0B

8진수: 0

16진수: 0X



항과 연산자

항 (operand): 연산에 사용되는 값

연산자 (operator): 항을 이요하여 연산하는 기호

![image-20191217131808056](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191217131808056.png)

대입 연산자:

int age = 20;

왼쪽 변수의 값이 오른쪽에 대입

우선 순위가 가장 낮은 연산자

부호연산자:

단항 연산자

변수의 부호를 유지하거나 (+) 바꿈(-)

실제 변수의 값이 변하려면 대입 연산자를 사용해야함

![image-20191217132429174](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191217132429174.png)

![image-20191217132623322](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191217132623322.png)

증가, 감소 연산자:

단항 연산자

대입 연산자의 의미가 있다

변수의 값을 1 더하거나 뺼 때 사용

연산자가 항의 앞에 있는가 뒤에 있는가에 따라 그 결과가 달라짐

++ : 항의 값에 1을 더합니다

val = ++ num; // 먼저 num 값이 1 증가한 후 val 변수에 대입

val = num++; // val 변수에 기존 num 값을 먼저 대입한 후 num 값 1 증가

-- : 항의 값에서 1을 뺍니다

val = --num; // 먼저 num 값이 1 감소한 후 val 변수에 대입

관계연산자: python과 같음

논리연산자: true/ false 반환

![image-20191229143120940](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191229143120940.png)

단락 회로 평가: &&은 앞의 항이 false이면 뒤 항의 결과를 평가하지 않아도 false임. || 은 앞의 항이 true면 뒤 항의 결과를 평가하지 않아도 true임.

조건연산자:

삼항 연산자 == 조건식? 결과1: 결과 2;

ex) int num = (5>3)? 10:20;

비트연산자:

![image-20191229145953799](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191229145953799.png)

 대입연산자와 다른 연산자가 함께 쓰임

마스크: 특정 비트를 가리고 몇개의 비트 값만 사용할 떄

비트켜기: 특정 비트들만을 1로 설정해서 사용하고 싶을 때

비트끄기: 특정 비트들만을 0으로 설정해서 사용하고 싶을 때

비트 토글: 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 떄

![image-20191229150957617](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191229150957617.png)

if문, if -else문

switch-case문

![image-20191230212825435](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191230212825435.png)

switch-case문은 꼭 break를 써야한다. break를 쓰지 않으면 해당되는 case부터 그 밑에있는 모든 case를 실행한다.

default를 사용하지 않으면 변수에 초기값을 설정해줘야한다

자바7 부터 조건에 문자열 사용 가능 (이전에는 상수, 문자 정도만 가능)

for 문

for (초기화식; 조건식; 증감식) {

​	수행문;

​	...

}

조건에 들어가는 변수에는 반드시 초기값을 넣어줘야한다

초기화식과 증감식은 여러개 쓸 수 있다

< 을 <=보다 많이 쓴다.

어떠한 초기화식, 조건식, 증감식을 쓰지 않고 ;; 으로 쓰면 무한루프이다.

![image-20191230224311227](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191230224311227.png)

중첩 반복문을 쓸 때에는 속도가 제곱, 세제곱 등과 같이 증가하니 유의

외부 반복문과 내부 반복문 간의 변수 값 변화에 유의할 것

while 문

do-while 문

![image-20191230231336183](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20191230231336183.png)



## 클래스와 객체

객체(Object): 구체적, 추상적 데이터의 단위

객체 지향 프로그래밍

- 객체를 기반으로 하는 프로그래밍
- 객체를 정의하고, 객체의 기능을 구현하며, 객체간의 협력을 구현

절차 지향 프로그래밍

- 시간이나 사건의 흐름에 따른 구현
- c언어

클래스

- 객체를 코드로 구현한 것
- oop의 기본 요소
- 객체의 청사진

멤버 변수

- 객체가 가지는 속성을 변수로 표현
- 클래스의 멤버변수
- member variable, property, attribute

메서드

- 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수
- 메서드를 구현함으로써 객체의 기능이 구현됨
- 사용자(client) 입장에서 함수 이름을 짓는게 좋음
- method, member function

class 파일에는 여러 class가 들어갈 수 있다. 하지만 public class는 단 하나여야함. 파일명은 public class의 이름과 같아야한다.

함수 (function)

- 하나의 기능을 수행하는 일련의 코드
- 함수는 호출하여 사용하고 시능이 수행된 후 값을 반환 할 수 있음
- 함수로 구현된 기능은 여러 곳에서 호출되어 사용될 수 있음

- 이름, 매개변수, 반환 값, 함수 몸체(body)로 구성 됨
- 출력하는게 없으면 void를 붙인다

스택 메모리

- 함수 호출 시 스택메모리 사용
- 스택의 가장 밑에 main 함수가 들어감
-  지역변수는 스택에서 함수가 호출될 때 생겼다가, 함수가 종료되면 사라진다

인스턴스, 힙 메모리

인스턴스: 클래스로 부터 생성된 객체

힙메모리에 멤버 변수의 크기에 따라 메모리가 생성

클래스를 기반으로 new 키워드를 이용하여 여러 개의 인스턴스를 생성

![image-20200203165434936](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200203165434936.png)

힙: 동적 메모리

멤버 변수들은 힙에 저장된다

각각의 instance는 별개의 메모리를 갖는다

![image-20200203170538388](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200203170538388.png)

생성자, 생성자 오버로딩

생성자 (constructor)

- 객체를 생성할 때 new 키워드와 함께 호출 (객체 생성 외에는 호출할 수 없음)
- 인스턴스를 초기화하는 코드가 구현 됨 (주로 멤버 변수 초기화)
- 반환 값이 없음, 상속되지 않음
- 생성자는 클래스 이름과 동일

기본 생성자 (default constructor)

- 하나의 클래스에는 반드시 하나 이상의 생성자가 존재
- 프로그래머가 생성자를 구현하지 않으면 컴파일러가 새성자 코드를 넣어줌 => 기본 생성자
- 기본 생성자는 매개 변수가 없고, 구현부가 없음
- 만약 클래스에 다른 생성자가 있는 경우 대폴트 생성자는 제공되지 않음

생성자 오버로딩

- 생성자를 2개 이상 구현하는 경우
- 사용하는 코드에서 여러 생성자 중 선택하여 사용할 수 있음
- private 변수도 생성자를 이용하여 초기화를 할 수 있음

참조 자료형 (reference data type)

- 변수의 자료형: 기본 자료형, 참조 자료형
- 참조자료형은 클래스형으로 변수를 선언함 (ex String name;)

- 기본 자료형은 사용하는 메모리가 정해져 잇지만, 참조 자료형은 클래스에 따라 다름

- 참조 자료형은 직접 만들어 사용할 수 있음



정보 은닉

접근 제어자 (access modifier)

- 변수, 메서드, 생성자에 대한 접근 제한 지정
- public, private, protected, 아무것도 안 쓰는 경우 (기본 접근 제어자)
- private을 사용하면 클래스 외부에서는 접근할 수 없음
- 클래스 간의 상속 관계에 따라 제어자가 다름
- 상위 클래스의 private 변수를 하위 클래스에서 public하게 오픈하고 싶을 때 protected를 씀
- 기본 접근 제어자인 경우 같은 패키지가 아니면 접근 불가능
- public인 경우 다른 패키지여도 접근 가능

- 외부에서 클래스 내부의 정보에 접근하지 못하도록 하는 private 키워드를 활용
- private 변수를 외부에서 접근하게 하려면 public 메서드 제공함. 클래스 내부 데이터를 잘못 사용하는 오류를 방지할 수 있음. (set, get과 같은 메서드)

this에 대하여

this의 역할

- 자신의 메모리를 가리킴

- 생성자에서 다른 생성자를 호출 함

  ```
  public Person() {
  	this("이름없음", 1);
  }
  
  public Person(String name, int age){
  	this.name = name;
  	this.age = age;
  }
  ```

  

- 인스턴스 자신의 주소를 반환

객체 간 협력

static 변수, 메서드

여러 인스턴스가 하나의 값을 공유할 필요가 있음

인스턴스가 생성될 때 마다 생성되는 것이 아니기 때문에, 단 한 번 생성되어 메모리에 저장된다

static 변수는 처음 프로그램이 로드 될 때 데이터 영역에 생성됨

인스턴스의 생성과 상관 없이 사용할 수 있으므로 클래스 이름으로 참조

클래스 변수, 정적 변수 라고도 함

![image-20200204154041357](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200204154041357.png)

static 변수를 사용하기 위해 static method를 사용

다른 method에서 static 변수를 사용해도 되지만, static method 안에서 인스턴스 변수를 사용하지 말 것. (좋은 코드 습관 x)

static 변수는 큰 메모리를 잡으면 안된다. 그러면 안좋은 프로그램이 됨.

![image-20200204155120113](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200204155120113.png)

변수 유형을 잘 공부해서 맞는 변수 유형을 쓰는 것이 중요하다. 변수의 라이프 사이클을 정확히 이해할 것.

그래야 프로그램의 효율성이 올라감

singleton pattern

- 단 하나만 존재하는 인스턴스
- 생성자는 private
- static으로 유일한 객체 생성
- 외부에서 유일한 객체를 참조할 수 있는 public static get() 메서드 구현



## 배열과 ArrayList

배열

- 동일한 자료형의 순차적 자료 구조

- 배열 선언하기 (길이를 선언하고 간다; fixed length)

  ```java
  int[] arr = new int[10];
  int arr[] = new int[10];
  ```

- 메모리 구조

![image-20200204162420460](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200204162420460.png)

- 연속된 자료구조
- 중간에 비게 하면 안된다. 그러면 끝났다고 인식함.

객체 배열

기본자료형 배열

```java
int[] arr = new int[10];
```

참조 자료형 배열

```java
Book[] library = new Book[5];
```

객체의 주소를 담게 된다

처음에 만들면 null 값이 들어간다. 객체를 넣을려면 new를 전부 해줘야함. 착각하지 말 것.

배열 복사

```java
int[] arr1 = {10, 20, 30, 40, 50};
int[] arr2 = {1, 2, 3, 4, 5};

System.arraycopy(arr1, 0, arr2, 1, 3);
// arr1에서 0번째 값부터 3개를 arr2의 1번째 값부터 3개 복사

//결과
arr2 = {1, 10, 20, 30, 4, 5}
```

향상된 for loop(enhanced for)

```java
for (Book book: library) {
}
// for (변수: 배열) {반복 실행문}
```

얕은 복사, 깊은 복사가 있음

얕은 복사를 하면 새로운 memory를 배정하는 것이 아니고, 같은 주소 값을 가르키고 있다.

깊은 복사를 해야 진짜로 다른 array가 생김

다차원 배열

2차원 이상의 배열

지도, 게임, 평면이나 공간을 구현할 때 사용

```
int[][] arr = new int[2][3]
// 자료형 배열 이름 행개수 열개수
```

ArrayList

자바에서 제공되는 객체 배열이 구현된 클래스

객체 배열을 사용하는데 필요한 여러 메서드들이 구현되어 있음

주요 메서드

![image-20200204183748051](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200204183748051.png)

생성할 때 타입을 <> 안에 선언해줘야 한다

## 상속과 다형성

클래스 상속

새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능이 확장되는 클래스를 구현함

상속하는 클래스: 상위 클래스, parent class, super class

상속받는 클래스: 하위 클래스,child class, derived class, subclass

class B(하위) extends A(상위) {}

상위 클래스는 하위 클래스 보다 일반적인 개념과 기능을 가짐

하위 클래스는 상위 클래스보다 구체적인 개념과 기능을 가짐

extends 뒤에는 단 하나의 class 만 사용할 수 있음

자바는 single inheritance만을 지원함

protected 예약어

외부 클래스에는 privated으로 하위 클래스에서 public의 기능을 구현한 키워드

상위 클래스에 protected로 선언된 변수나 메서드는 다른 외부 클래스에서는 사용할 수 없지만 하위 클래스에서는 사용 가능

![image-20200204203310807](C:\Users\DAHEA MOON\AppData\Roaming\Typora\typora-user-images\image-20200204203310807.png)

 **상속에서 클래스 생성 과정과 형 변환**

**하위 클래스가 생성되는 과정**

- 하위 클래스가 생성될 때 상위 클래스가 먼저 생성 됨
- 상위 클래스의 생성자가 호출되고 하위 클래스의 생성자가 호출됨
- 하위클래스의 생성자에서는 무조건 상위클래스의 생성자가 호출되어야함
- 하위 클래스에서 상위 클래스의 생성자를 호출하는 코드가 없는 경우 컴파일러는 상위 클래스 기본 생성자를 호출하기 위한 super() 를 추가함
- super()로 호출되는 생성자는 상위 클래스의 기본 생성자임
- 만약 상위 클래스의 기본 생성자가 없는 경우 (매개변수가 있는 생성자만 존재하는 경우) 항위 클래스는 명시적으로 상위 클래스의 생성자를 호출해야함

**상속에서의 메모리 상태**

상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성됨

상위 클래스로의 묵시적 형 변환 **(업캐스팅)**

상위클래스 형으로 변수를 선언하고 하위클래스 인스턴스를 생성할 수 있음

하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로 묵시적 형변환이 가능 함

상속관계에서 모든 하위 클래스는 상위클래스로 묵시적 형 변환이 됨. 그 역은 성립하지 않음.

**형 변환에서의 메모리**

```java
Customer vc = new VIPCustomer();
```

이 경우 vc 변수는 customer 클래스의 멤버 변수와 메서드만 사용 가능

vipcustomer() 생성자 호출로 인스턴스는 모두 생성되었지만 타입이 customer 이므로 접근할 수 있는 변수나 메서드는 customer의 변수와 메서드임

하위클래스에서 메서드 오버라이딩을 했다면, 형 변환을 해도 하위클래스의 메서드가 호출된다.

**메서드 오버라이딩**

오버라이딩(overriding)

상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 메서드를 재정의 할 수 있음

@Override 애노테이션 (annotation)

재정의된 메서드라는 의미로 선언부가 기존의 메서드와 다른 경우 에러 발생

애노테이션은 컴파일러에게 특정한 정보를 제공해주는 역할

주로 사용되는 자바에서 제공되는 애노테이션

@Override: 재정의된 메서드라는 정보 제공

@FunctionalInterface: 함수형 인터페이스라는 정보 제공

@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨

@SuppressWarnings: 특정 경고가 나타나지 않도록함

**가상메서드(virtual method)**

메서드의 이름과 메서드 주소를 가진 가상 메서드 테이블에서 호출될 메서드의 주소를 참조함

오버라이딩된 메서드가 있으면 같은 이름의 메서드가 있는 것인데, 컴파일 할 때 매개변수에 따라 다른 메서드 주소를 가지게 된다.

같은 이름의 메서드는 생성된 인스턴스를 기반으로 호출된다.

**다형성(polymorphism)**

하나의 코드가 여러 자료형으로 구현되어 실행되는 것

같은 코드에서 여러 실행 결과가 나옴

정보은닉, 상속과 더불어 oop 의 가장 큰 특징 중 하나

oop의 유연성, 재활용성, 유지보수성에 기본이 되는 특징이다

**다운 캐스팅과 instanceof**

다운 캐스팅: 하위 ㅋ르래스로 형 변환

묵시적으로 상위클래스 형변환된 인스턴스가 원래 자료형인 하위클래스롱 변환되어야 할 때 다운 캐스팅이라 함

하위클래스로의 형 변환은 면시적으로 되어야함

```java
// 묵시적
Customer vc = new VIPCustomer();
// 명시적
VIPCustomer vCustomer = (VIPCustomer)vc;
```

instanceof 는 변수가 클래스에 포함되는지 확인. true/false를 반환함.



## 추상 클래스

추상 클래스:  추상 메서드를 포함한 클래스

추상 메서드: 구현 코드가 없이 선언부만 있는 메서드

abstract 예약어 사용

추상 클래스는 new (인스턴스화) 할 수 없음

cf) concrete class <-> abstract class

추상클래스는 상위클래스로 사용되고, 추상메서드는 하위 클래스에서 구체적으로 구현된다

추상 클래스에서 구현된 메서드는 하위클래스에서 오버라이딩 될 수 있다.

추상클래스를 상속받은 하위클래스는

1. 모든 추상 메서드를 override를 하거나
2. abstract class가 되어야 한다
3. 모든 메서드가 구현되어도 클래스에 abstract 키워드를 사용할 수도 있다

**템플릿 메서드**

템플릿: 틀이나 견본

템플릿 메서드: 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의해 놓은 메서드. final로 선언하여 재정의 할 수 없게 함.

템플릿 메서드 패턴: 디자인 패턴의 일종. 프레임워크에서 많이 사용되는 설계 패턴. 추상 클래스로 선언된 상의 클래스에서 추상 메서드를 이용하여 전체 구현의 흐름을 정의하고 구체적인 각 메서드 구현은 하위 클래스에 위임함. 하위 클래스가 다른 구현을 했다고 해서 템플릿 메서드에 정의된 시나리오 대로 수행됨.

final 예약어

final 변수는 값이 변경될 수 없는 상수임. 오직 한 번만 값을 할당.

final 메서드는 하위 클래스에서 재정의가 불가능

final 클래스는 더이상 상속되지 않음